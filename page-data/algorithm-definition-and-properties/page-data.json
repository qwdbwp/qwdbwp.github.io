{"componentChunkName":"component---src-templates-blog-template-js","path":"/algorithm-definition-and-properties/","result":{"data":{"cur":{"id":"ad083eb6-6f88-5d26-9605-ac6b46cdc88a","html":"<h1 id=\"알고리즘\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘</h1>\n<p>정의: 유한한 시간 안에 적절한 입력을 받아 필요한 출력을 얻는 문제를 풀기 위한 명확한 명령들의 나열</p>\n<ul>\n<li>\n<p>각각의 단계는 중의성이 없는 명령이어야 함</p>\n</li>\n<li>\n<p>알고리즘이 동작하는 입력의 범위가 명시되어야 함</p>\n</li>\n<li>\n<p>같은 알고리즘도 다른 방식으로 표현할 수 있음</p>\n</li>\n<li>\n<p>같은 문제를 해결하기 위한 알고리즘도 여러 방식이 있을 수 있음</p>\n</li>\n</ul>\n<h3 id=\"알고리즘의-속성\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%86%8D%EC%84%B1\" aria-label=\"알고리즘의 속성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘의 속성</h3>\n<ul>\n<li>\n<p>유한성: 유한한 step 이후 정지해야 함</p>\n</li>\n<li>\n<p>명확성: 모호하지 않고 정확해야 함</p>\n<p>유효한 입력이 명확하게 명시되어야 함</p>\n<p>기대하는 출력이 명시되어야 함</p>\n</li>\n<li>\n<p>효율성: 명령 하나하나는 간결해야 함</p>\n</li>\n</ul>\n<h3 id=\"알고리즘을-공부해야-하는-이유\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EA%B3%B5%EB%B6%80%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"알고리즘을 공부해야 하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘을 공부해야 하는 이유</h3>\n<ul>\n<li>\n<p>실용적 이유: 중요한 알고리즘의 표준 집합을 알아야 함, 새로운 알고리즘을 디자인하고 효율성을 분석해야 함</p>\n</li>\n<li>\n<p>이론적 이유: 알고리즘은 컴퓨터과학의 초석이 되는 학문임, 분석하는 능력을 기를 수 있음</p>\n</li>\n</ul>\n<h2 id=\"알고리즘의-해결-과정\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%B4%EA%B2%B0-%EA%B3%BC%EC%A0%95\" aria-label=\"알고리즘의 해결 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘의 해결 과정</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">문제를 이해 → 문제를 풀 방법을 결정 → 알고리즘 디자인 → 알고리즘 검증 → 알고리즘 분석 → 알고리즘 코딩</code></pre></div>\n<h3 id=\"문제를-이해\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%9D%B4%ED%95%B4\" aria-label=\"문제를 이해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제를 이해:</h3>\n<ul>\n<li>\n<p>문제의 special cases를 생각해 보기</p>\n</li>\n<li>\n<p>알려진 알고리즘이 있다면 사용하고, 없다면 만들어야 함</p>\n</li>\n<li>\n<p>대부분의 입력에 작동하는 알고리즘이 아닌 모든 유효한 입력에 대해 작동해야 함</p>\n</li>\n<li>\n<p>컴퓨터 가용 속도와 메모리 확인</p>\n</li>\n</ul>\n<h3 id=\"문제-해결-방법-결정\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95-%EA%B2%B0%EC%A0%95\" aria-label=\"문제 해결 방법 결정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 해결 방법 결정:</h3>\n<ul>\n<li>\n<p>정확한 알고리즘 vs 근사치 알고리즘</p>\n<p>근사치 알고리즘을 사용하는 경우:</p>\n<ul>\n<li>대부분 정확한 값을 알 수 없을 때 (ex. 루트, 적분 등)</li>\n<li>정확한 값을 계산하는 데에 너무 오래 걸릴 때 (경우의 수가 너무 많음)</li>\n<li>정확한 값을 구하는 과정 안에서 근사치 알고리즘이 필요할 때</li>\n</ul>\n</li>\n<li>\n<p>알고리즘 디자인 technique</p>\n<p>Brute force, Divide and conquer, Decrease and conquer 등</p>\n</li>\n</ul>\n<h3 id=\"알고리즘-디자인\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%94%94%EC%9E%90%EC%9D%B8\" aria-label=\"알고리즘 디자인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘 디자인:</h3>\n<ul>\n<li>\n<p>알고리즘에 적합한 자료구조를 결정</p>\n</li>\n<li>\n<p>알고리즘 표현: 자연어 (모호함이 있음) / Pseudocode (가장 많이 쓰임)</p>\n</li>\n</ul>\n<h3 id=\"알고리즘-검증\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B2%80%EC%A6%9D\" aria-label=\"알고리즘 검증 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘 검증:</h3>\n<p>모든 유효한 입력에 대해 유한한 시간 내에 원하는 출력을 얻을 수 있는지 증명</p>\n<h3 id=\"알고리즘-분석\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D\" aria-label=\"알고리즘 분석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘 분석:</h3>\n<ul>\n<li>\n<p>시간 효율성: 얼마나 빠른지</p>\n</li>\n<li>\n<p>공간 효율성: 메모리를 얼마나 사용하는지</p>\n</li>\n<li>\n<p>단순성: 단순할수록 프로그램으로 구현하기 쉽고 더 효율적</p>\n</li>\n</ul>\n<p>알고리즘 코딩: 좋은 알고리즘이 비효율적으로 구현될 수 있음</p>\n<p><span style=\"color:gray\"> 이 포스트는 2022-1 이도길 교수님의 COSE214 알고리즘 강의와 Introduction to The Design and Analysis of Algorithms(3rd Edition) (Anany Levitin 저) 교재를 참고하여 작성되었습니다.</span></p>","excerpt":"알고리즘 정의: 유한한 시간 안에 적절한 입력을 받아 필요한 출력을 얻는 문제를 풀기 위한 명확한 명령들의 나열 각각의 단계는 중의성이 없는 명령이어야 함 알고리즘이 동작하는 입력의 범위가 명시되어야 함 같은 알고리즘도 다른 방식으로 표현할 수 있음 같은 문제를 해결하기 위한 알고리즘도 여러 방식이 있을 수 있음 알고리즘의 속성 유한성: 유한한 step 이후 정지해야 함 명확성: 모호하지 않고 정확해야 함 유효한 입력이 명확하게 명시되어야 함 기대하는 출력이 명시되어야 함 효율성: 명령 하나하나는 간결해야 함 알고리즘을 공부해야 하는 이유 실용적 이유: 중요한 알고리즘의 표준 집합을 알아야 함, 새로운 알고리즘을 디자인하고 효율성을 분석해야 함 이론적 이유: 알고리즘은 컴퓨터과학의 초석이 되는 학문임, 분석하는 능력을 기를 수 있음 알고리즘의 해결 과정 문제를 이해: 문제의 special cases를 생각해 보기 알려진 알고리즘이 있다면 사용하고, 없다면 만들어야 함 대부분의 입력…","frontmatter":{"date":null,"title":"[Algorithms 알고리즘] 알고리즘의 정의와 성질","categories":"Algorithms","author":"이예슬","emoji":"📟"},"fields":{"slug":"/algorithm-definition-and-properties/"}},"next":{"id":"e3a35f05-62f3-5066-b9ff-f533ac78964e","html":"<h1 id=\"list\" style=\"position:relative;\"><a href=\"#list\" aria-label=\"list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>List</h1>\n<h2 id=\"array배열\" style=\"position:relative;\"><a href=\"#array%EB%B0%B0%EC%97%B4\" aria-label=\"array배열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Array(배열)</strong></h2>\n<p><strong>element의 index에 의해 순서가 유지된다</strong></p>\n<p>장점: Search가 매우 효율적</p>\n<p>단점: 삽입과 삭제가 복잡하고 비효율적</p>\n<p>→ 리스트가 자주 변화될 때는 잘 사용하지 않음</p>\n<h2 id=\"linked-list\" style=\"position:relative;\"><a href=\"#linked-list\" aria-label=\"linked list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Linked list</strong>:</h2>\n<p>ordered collection of data in which each element contains the location of the next element</p>\n<p>Consist of Data &#x26; links</p>\n<p>Links: chain the data together, contain pointers that identify the next element</p>\n<p>Linear linked lists: each element has only zero or one successor</p>\n<p>Non-linear linked list: each element can have zero, one or more successors</p>\n<p>장점: 삽입과 삭제가 쉬움, 새로운 element를 위해 shift하지 않아도 됨</p>\n<p>단점: 물리적으로 연결되어있지 않기 때문에 탐색에 제약 (sequential search 만 가능)</p>\n<p>Node:</p>\n<p>Data: single field, multiple fields, structure that contains other fields 모두 가능</p>\n<p>Self-referential structure (자기 참조 구조)</p>\n<p>Data field는 어떤 자료형이든 될 수 있음 → void pointer</p>\n<p>Generic Code for ADT: 하나의 코드로 어떤 data type에도 사용할 수 있음</p>\n<p>C언어의 ADT: C는 strongly typed laguage</p>\n<p>pointer to void : cast 하지 않고도 assign 할 수 있음</p>\n<p>참조는 casting 없이 쉽게 되지만, 역참조는 casting이 필수적</p>\n<h2 id=\"linear-list\" style=\"position:relative;\"><a href=\"#linear-list\" aria-label=\"linear list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Linear list</strong></h2>\n<p>a list in which each element has a unique successor</p>\n<p>Restricted lists</p>\n<p>삽입과 삭제가 리스트의 끝에서만 일어남</p>\n<p>LIFO(last in - first out) - stack</p>\n<p>FIFO(first in - first out) - queue</p>\n<p>General lists</p>\n<p>검색, 삽입, 삭제와 같은 연산이 리스트의 어디에서나 일어날 수 있음</p>\n<p>기본 연산: 삽입, 삭제, 검색, 순회</p>\n<p>삽입:</p>\n<p>Ordered list: 순서가 유지되는 리스트, key값 기준</p>\n<p>삽입(insertion):</p>\n<p>데이터를 삽입할 위치를 찾기 위해 검색이 먼저 일어나야 함</p>\n<p>삭제(deletion):</p>\n<p>데이터를 삭제할 위치를 찾기 위해 검색이 먼저 일어나야 함</p>\n<p>검색(Retrival): 리스트의 내용에 영향을 주지 않음</p>\n<p>순회(Traversal): 리스트의 처음부터 마지막까지 실행</p>\n<p>Random list: 보통 리스트의 끝에 삽입, 데이터 수집 시 사용</p>\n<h3 id=\"data-structure-of-linked-list\" style=\"position:relative;\"><a href=\"#data-structure-of-linked-list\" aria-label=\"data structure of linked list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data structure of linked list</h3>\n<p>Head node: head pointer &#x26; data about the list (metadata)</p>\n<p>Data node: data fields와 link로 구성, 그 중 하나는 검색을 위한 key field</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">Algorithm <span class=\"token function\">Createlist</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token comment\">// Initializes metadata for list</span>\r\n<span class=\"token comment\">// Pre    list is metadata structure passed by reference</span>\r\n<span class=\"token comment\">// Post   metadata initialized</span>\r\n\t<span class=\"token function\">allcate</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span> <span class=\"token comment\">// allocates the head structure</span>\r\n\tset list head to null\r\n\tset list count to <span class=\"token number\">0</span> <span class=\"token comment\">// initializes the metadata</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>삽입(Insert)</strong> : 삽입할 위치를 찾기 위해 선행자를 알아야 함</p>\n<ol>\n<li>새로운 노드에 대한 메모리를 할당하고, 노드에 데이터를 넣는다</li>\n<li>새로운 노드가 그 노드의 후행자를 가리키게 함</li>\n<li>새로운 노드의 선행자가 새로운 노드를 가리키게 함</li>\n</ol>\n<p>빈 리스트에 삽입하는 경우:</p>\n<p>리스트 헤더 포인터가 null인 상태</p>\n<p>새로운 노드가 리스트 헤드를 가리키게 함</p>\n<p>리스트 헤더 포인터가 새로운 노드를 가리키게 함</p>\n<p>리스트의 맨 처음에 삽입하는 경우:</p>\n<p>첫 노드의 앞에 삽입해야 함</p>\n<p>선행자가 null인 경우가 맨 앞에 삽입하는 경우임</p>\n<p>새로운 노드가 첫번째 노드를 가리키게 함</p>\n<p>헤드 포이너가 새로운 노드를 가리키게 함</p>\n<p>비어있는 리스트에 삽입하는 것과 리스트의 처음에 삽입하는 경우는 논리적으로 동일</p>\n<p>리스트의 중간에 삽입하는 경우:</p>\n<p>선행자가 특정 주소를 가지고 있음</p>\n<p>새로운 노드가 선행자의 후행자를 가리키게 함</p>\n<p>선행자가 새로운 노드를 가리키게 함</p>\n<p>리스트의 끝에 삽입하는 경우:</p>\n<p>새로운 노드가 선행자의 후행자를 가리키게 함</p>\n<p>선행자가 새로운 노드를 가리키게 함</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">Algorithm <span class=\"token function\">InsertNode</span> <span class=\"token punctuation\">(</span> list<span class=\"token punctuation\">,</span> pPre<span class=\"token punctuation\">,</span> dataIn <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token comment\">// Inserts data into a new node in the list</span>\r\n<span class=\"token comment\">/* Pre    list is metadata structure to a valid list\r\n\t\t\t\t\tpPre is pointer to data's logical predecessor\r\n\t\t\t\t\tdataIn contains data to be inserted\r\n\tPost    data have been inserted in sequence\r\n\tReturn  true if successful, false if memory overflow */</span>\r\n\t<span class=\"token function\">allocate</span> <span class=\"token punctuation\">(</span> pNew <span class=\"token punctuation\">)</span>\r\n\r\n\tset pNew data to dataIn\r\n\r\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> pPre null<span class=\"token punctuation\">)</span>\r\n\t<span class=\"token comment\">//adding before first node or to empty list</span>\r\n\t\tset pNew link to list head\r\n\t\tset list head to pNew\r\n\t<span class=\"token keyword\">else</span>\r\n\t<span class=\"token comment\">// addubg in middle or at end</span>\r\n\t\tset pNew link to pPre link\r\n\t\tset pPre link to pNew\r\n\tend <span class=\"token keyword\">if</span>\r\n\r\n\t<span class=\"token keyword\">return</span> true\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>삭제(Delete)</strong> :</p>\n<p>논리적: 리스트의 포인터를 변화시킴</p>\n<p>물리적: 노드의 동적 메모리를 해제</p>\n<p>삭제하고자 하는 노드의 주소와 선행자의 주소를 알아야 함</p>\n<p>선행자의 링크를 삭제할 노드의 후행자로 바꿈</p>\n<p>삭제할 노드의 메모리를 해제</p>\n<p>유일한 노드를 삭제하는 경우:</p>\n<p>리스트 헤드가 null이 됨</p>\n<p>첫번째 노드를 삭제하는 경우:</p>\n<p>선행자가 null</p>\n<p>헤드 포인터는 삭제할 노드의 후행자를 가리킴</p>\n<p>삭제할 노드의 메모리 해제</p>\n<p>중간이나 마지막 노드를 삭제하는 경우:</p>\n<p>선행자 노드가 삭제할 노드의 후행자를 가리키게 함</p>\n<p>(마지막 노드를 삭제할 경우 선행자의 후행자는 null이 됨)</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">Algorithm <span class=\"token function\">DeleteNode</span> <span class=\"token punctuation\">(</span> list<span class=\"token punctuation\">,</span> pPre<span class=\"token punctuation\">,</span> pLoc<span class=\"token punctuation\">,</span> dataOut<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n<span class=\"token comment\">/* Deletes data from list &amp; returns it to calling module\r\nPre    list is metadata structure to a valid list\r\n\t\t\t Pre is a pointer to predecessor node\r\n\t\t\t pLoc is a pointer to node to e deleted\r\n\t\t\t dataOut is variable to receive deleted data\r\nPost   data have been deleted and returned to caller */</span>\r\n\tmove pLoc data to dataOut\r\n\r\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pPre null<span class=\"token punctuation\">)</span>\r\n\t<span class=\"token comment\">// deleting first node</span>\r\n\t\tset list head to pLoc link\r\n\t<span class=\"token keyword\">else</span> \r\n\t<span class=\"token comment\">// deleting other nodes</span>\r\n\t\tset pPre link to pLoc link\r\n\tend <span class=\"token keyword\">if</span>\r\n\r\n\t<span class=\"token function\">recycle</span> <span class=\"token punctuation\">(</span>pLoc<span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Search(검색)</strong>: 삽입과 삭제 모두 search가 먼저 필요함</p>\n<p>Linked list이기 때문에 sequential search만 가능함</p>\n<p>Classic sequential search: 찾으면 그 위치의 주소, 못 찾으면 마지막의 주소</p>\n<p>Ordered list search: 찾으면 그 위치의 주소, 못 찾으면 있어야 하는 위치의 주소</p>\n<p>Key값이 주어졌을 때 리스트에서 key를 검색. 찾으면 true, 못 찾으면 false</p>\n<p>처음부터 시작, 타겟값이 현재 노드의 키값보다 크지 않을 때에만 검색을 진행</p>\n<p>현재 노드와 타겟값이 같으면 true 리턴, 현재 노드의 값이 더 작으면 false 리턴</p>\n<table>\n<thead>\n<tr>\n<th>Condition</th>\n<th>pPre</th>\n<th>pLoc</th>\n<th>return</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>target &#x3C; first node</td>\n<td>Null</td>\n<td>First node</td>\n<td>false</td>\n</tr>\n<tr>\n<td>target = first node</td>\n<td>Null</td>\n<td>First node</td>\n<td>true</td>\n</tr>\n<tr>\n<td>first &#x3C; target &#x3C; last</td>\n<td>Largest node &#x3C; target</td>\n<td>first node > target</td>\n<td>false</td>\n</tr>\n<tr>\n<td>target = middle node</td>\n<td>node’s predecessor</td>\n<td>equal node</td>\n<td>true</td>\n</tr>\n<tr>\n<td>target = last node</td>\n<td>last’s predecessor</td>\n<td>last node</td>\n<td>true</td>\n</tr>\n<tr>\n<td>target > last node</td>\n<td>last node</td>\n<td>null</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">Algorithm <span class=\"token function\">SearchList</span> <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> pPre<span class=\"token punctuation\">,</span> pLoc<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n\tset pPre to null\r\n\tset pLoc to list head\r\n\t<span class=\"token function\">loop</span> <span class=\"token punctuation\">(</span> pLoc not null AND target <span class=\"token operator\">></span> pLoc key<span class=\"token punctuation\">)</span>\r\n\t\tset pPre to pLoc\r\n\t\tset pLoc to pLoc link\r\n\tend loop\r\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span> pLoc null<span class=\"token punctuation\">)</span>\r\n\t<span class=\"token comment\">// set return value</span>\r\n\tset found to false\r\n\t<span class=\"token keyword\">else</span>\r\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>target equal pLoc key<span class=\"token punctuation\">)</span>\r\n\t\t\tset found to true\r\n\t\t<span class=\"token keyword\">else</span>\r\n\t\t\tset found to false\r\n\t\tend <span class=\"token keyword\">if</span>\r\n\tend <span class=\"token keyword\">if</span>\r\n\r\n<span class=\"token keyword\">return</span> found\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Traverse(순회)</strong>: 전체 노드의 값을 바꿀 때, 리스트 값을 출력, 전체 노드 값을 더하기, 평균을 구할 때</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">getNext</span> <span class=\"token punctuation\">(</span> list<span class=\"token punctuation\">,</span> fromWhere<span class=\"token punctuation\">,</span> dataOut<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>empty list<span class=\"token punctuation\">)</span>\r\n\t\treutrn false\r\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fromWhere is beginning<span class=\"token punctuation\">)</span>\r\n\t\tset list pos to list head\r\n\t\tmove current list data to dataOut\r\n\t\t<span class=\"token keyword\">return</span> true\r\n\t<span class=\"token keyword\">else</span>\r\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>end of list<span class=\"token punctuation\">)</span>\r\n\t\t<span class=\"token comment\">// end of list</span>\r\n\t\t\t<span class=\"token keyword\">return</span> false\r\n\t\t<span class=\"token keyword\">else</span>\r\n\t\t\tset list pos to next node\r\n\t\t\tmove current list data to dataOut\r\n\t\t\t<span class=\"token keyword\">return</span> true\r\n\t\tend <span class=\"token keyword\">if</span>\r\n\tend <span class=\"token keyword\">if</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Destroy List: 남은 노드들을 다 삭제하고, 메타데이터를 null list condition으로 바꾼다</p>\n<p>Circularly linked lists: 마지막 노드가 리스트의 첫번째 노드를 가리키게 함</p>\n<p>삽입과 삭제: 마지막 노드를 제외하고 기본 logic은 같음</p>\n<p>마지막 노드를 삽입하거나 삭제할 때는 링크가 첫번째 노드를 가리키도록 해야 함</p>\n<p>검색: 검색하기 시작한 노드보다 앞에 타겟값이 있을 때, 한 바퀴 돌아서 찾을 수 있음</p>\n<p>시작한 자리의 주소를 저장하고 그 주소 전까지만 검색해야 함</p>\n<p><strong>Doubly linked lists</strong>: 두 후행자를 가짐 (forward pointer &#x26; backward pointer)</p>\n<p>역방향으로도 이동이 가능</p>\n<p><strong>삽입</strong>:</p>\n<p>Null list에 삽입할 때: 리스트의 head와 rear 포인터가 새로운 노드를 가리키게 함</p>\n<p>두 노드 사이에 삽입할 때: 새로운 노드의 선행자는 선행자로, 후행자는 선행자의 후행자로, 선행자의 후행자는 새로운 노드로, 후행자의 선행자는 새로운 노드로 포인터 변경</p>\n<p>리스트의 마지막에 삽입할 때: 새로운 노드의 후행자를 null로 변경</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">insertDbl</span> <span class=\"token punctuation\">(</span> list<span class=\"token punctuation\">,</span> dataIn <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>full list<span class=\"token punctuation\">)</span>\r\n\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\r\n\tend <span class=\"token keyword\">if</span>\r\n\r\n\tset found to <span class=\"token function\">searchList</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> predecessor<span class=\"token punctuation\">,</span> succssor<span class=\"token punctuation\">,</span> dataIn key<span class=\"token punctuation\">)</span>\r\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>not found<span class=\"token punctuation\">)</span>\r\n\t\tallocate new node\r\n\t\tmove dataIn to new node\r\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>predecessor is null<span class=\"token punctuation\">)</span>\r\n\t\t<span class=\"token comment\">// inserting before first node or into empty list</span>\r\n\t\t\tset new node back pointer to null\r\n\t\t\tset new node fore pointer to list head\r\n\t\t\tset list head to new node\r\n\t\t<span class=\"token keyword\">else</span>\r\n\t\t<span class=\"token comment\">// inserting into middle or end of list</span>\r\n\t\t\tset new node fore pointer to predecessor fore pointer\r\n\t\t\tset new node back pointer to predecessor\r\n\t\tend <span class=\"token keyword\">if</span>\r\n\t\t\r\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>predecessor fore null<span class=\"token punctuation\">)</span> \r\n\t\t\t<span class=\"token comment\">// inserting at end of list - set rear pointer</span>\r\n\t\t\tset list rear to new node\r\n\t\t<span class=\"token keyword\">else</span>\r\n\t\t\t<span class=\"token comment\">// inserting in middle of list - point successor to new</span>\r\n\t\t\tset successor back to new node\r\n\t\tend <span class=\"token keyword\">if</span>\r\n\t\tset predecessor fore to new node\r\n\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\r\n\tend <span class=\"token keyword\">if</span>\r\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">2</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">deleteDbl</span> <span class=\"token punctuation\">(</span> list<span class=\"token punctuation\">,</span> deleteNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>deleteNode back not null<span class=\"token punctuation\">)</span>\r\n\t<span class=\"token comment\">// point predecessor to successor</span>\r\n\t\tset predecessor to deleteNode back\r\n\t\tset predecessor fore to deleteNode fore\r\n\t<span class=\"token keyword\">else</span>\r\n\t<span class=\"token comment\">// update head pointer</span>\r\n\t\tset list head to deleteNode fore\r\n\tend <span class=\"token keyword\">if</span>\r\n\t\r\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>deleteNode fore not null<span class=\"token punctuation\">)</span>\r\n\t<span class=\"token comment\">// point successor to predecessor</span>\r\n\t\tset successor to deleteNode fore\r\n\t\tset successor back to deleteNode back\r\n\t<span class=\"token keyword\">else</span>\r\n\t<span class=\"token comment\">// point rear to predecessor</span>\r\n\t\tset list rear to deleteNode back\r\n\tend <span class=\"token keyword\">if</span>\r\n\t\r\n\t<span class=\"token function\">recycle</span> <span class=\"token punctuation\">(</span>deleteNode<span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Multilinked list: 두개 혹은 그 이상의 key sequences를 가짐</p>\n<p>같은 데이터 집합이 다른 sequence 안에 쓰일 수 있다</p>","frontmatter":{"date":"January 30, 2023","title":"[Data Structure 자료구조] List와 Linked list","categories":"data_structure","author":"이예슬","emoji":"💫"},"fields":{"slug":"/datastructure-list/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://qwdbwp.github.io","comments":{"utterances":{"repo":"https://github.com/qwdbwp/qwdbwp.github.io.git"}}}}},"pageContext":{"slug":"/algorithm-definition-and-properties/","nextSlug":"/datastructure-list/","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}